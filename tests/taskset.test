#!/bin/bash

[ -f testing.sh ] && . testing.sh

#testing "name" "command" "result" "infile" "stdin"

CPUS=$(($(nproc)+0))
if [ $CPUS -lt 2 ]
then
  echo "$SHOWSKIP: taskset (not SMP)"
  return 2 > /dev/null
  exit
fi
# Masks can be >64 bits but shell bitshifts usually can't
MOVER= LOVER= CCNT=$CPUS
while [ $CCNT -gt 8 ]; do MOVER+=ff; LOVER+=00; CCNT=$((CCNT-8)); done
[ $CCNT -gt 0 ] &&
  MASK=$(printf %x $(((1<<CCNT)-1)))$MOVER &&
  LAST=$(printf %x $((1<<(CCNT-1))))$LOVER

testcmd 'set mask to all' '$MASK taskset -p $BASHPID | sed "s/.*: //"' "$MASK\n" '' ''
testcmd 'set mask to first' '1 taskset -p $BASHPID | sed "s/.*: //"' '1\n' '' ''
testcmd 'set mask to last' '$LAST taskset -p $BASHPID | sed "s/.*: //"' "$LAST\n" '' ''
testcmd '-p 0 is current process' '1 taskset -p 0 | sed "s/.*: //"' '1\n' '' ''
toyonly testcmd 'no arguments shows current mask' '1 taskset' '1\n' '' ''
testcmd 'run on first' '1 ps -o psr= $BASHPID | xargs' '0\n' '' ''
testcmd 'run on last' '$LAST ps -o psr= $BASHPID | xargs' "$((CPUS-1))\n" '' ''
testcmd "long mask doesn't segfault" \
  '$(printf %99999s | tr \  0)f echo; echo $?' '\n0\n' '' ''
testcmd "error checking" '0 echo nope 2>/dev/null; echo $?' '1\n' '' ''
testcmd "error checking2" 'walrus echo nope 2>/dev/null; echo $?' '1\n' '' ''
